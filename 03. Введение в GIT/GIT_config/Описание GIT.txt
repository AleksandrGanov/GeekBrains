базовые команды:
-----------------------
git init (команда создания репозитория)
git add. добавляем изменения в индекс (можно указать конкретный файл вместо точки)
git commit -m "коммент" (можно не указывать коммент, тогда он откроется во внешнем  редакторе)
git commit -a (сразу коммитит все изменения, то есть не надо предварительно добавлять изменения в индекс командой add)

статус, изменения:
------------------------
git status (проверка статуса проекта)
git status -s (краткий формат вывода стутаса, D - удаленный, ?? - не отслеживамые файлы, ЬM - измененные (modified))
git diff (вывести что изменилось в файлах)
git diff --cached (вывести те изменения, которые сейчас в индексе, но еще не закомичены)
git diff имя_ветки (просмотр последних изменений в определенной ветке)

вывод лога:
---------------
git log (запрос лога, для выхода из режима лога нажимаем q)
git log -2 (запрос лога с ограничением вывода коммитов, для выхода из режима лога нажимаем q)
git log -p (запрос лога с детальным выводом информации по каждому коммиту, для выхода из режима лога нажимаем q)
git log --stat (запрос лога со статистикой по каждому коммиту, для выхода из режима лога нажимаем q)
git log --pretty=oneline (вывод лога в однострочном виде) 
git log --pretty=format: "прописываем формат" (вывод лога в собственном формате) 
git log --since:2.week (период вывода "от" и до "сегодня", то есть в примере "от двух недель назад до сегодня")
git log --until:1.week  (период вывода "с самого начала" до "until назад от сегодняшего дня", то есть в примере "с самого начала до недели назад")
-- можно одновременно использовать и since и intil
-- можно указывать точные даты --since=2019-03-01 --until=2019-03-25
git log --SGit -p (фраза после -S - это строка, которую система будет искать в изменениях)
git log --author="Ganov Alexander" (вывод коммитов определенного автора)
git blame hello.txt (указываем название файла и GIT выведет автора, хэш и дату каждой строки файла)
git log -4 --graph (просмотр графа слияния веток, 4 - глубина просмотра коммитов)

откат изменений:
----------------------
git check out -- название файла (затирает последние изменения в файле и восстанавливает из СКВ, в случае если файл еще не добавлен в индекс)
git restore -- название файла (-----//------)
git restore --staged название файла (убирает указанный файл из индекса)

отложить проиндексированные изменения:
-------------------------------------------------------------
git stash (откладываем изменения, чтобы можно было поработать с другой веткой репозитория)
git stash list (получить список отложенных изменений)
git stash apply (применить список отложенных изменений)
git stash apply@{1} (явное указание метки записи, которая должна быть применена, в случая наличия нескольких отложенных записей)
git stash drop (очистка списка stash)

версионирование:
-------------------------
git tag v.1.0.0 (создание тега версии, где v.1.0.0 произвольный тег версии)
git tag -a v.1.0.0 -m "Комментарий" (теги можно снабжать комментами, для этого используются опции -a и -m)
git tag -a v.1.0.0 -m "Комментарий" ff625614764adca7c8e56846ce3694ab2912b8cb (для установки тега на произвольный коммит дополнительной указываем ХЭШ коммита, можно использовать сокращенный ХЭШ, например, git tag -a v.1.0.0 -m "Комментарий" ff62561)
git tag (просмотр списка доступных тегов)
git tag -l v.1.0.* (поиск тегов по шаблону, зведочка - любые другие символы в любом количестве)
git tag -d v.1.0.0 (удаление тега)
git show (показывает изменения, содержащиеся в текущем теге)
git show v.1.0.0 (показывает изменения, содержащиеся в указанном теге)
git show ff625614764adca7c8e56846ce3694ab2912b8cb (можно обращаться по ХЭШу, результат будет тот же)
git show HEAD (отображение данных последнего коммита)
git show HEAD~1 (отображение данных предпоследнего коммита и так далее)
!!! отправку/запрос тегов в/из ремоут-репозиторий смотри в разделе "ремоут-репозиторий" !!!!

запуск графических оболочек:
--------------------------------------
gitk (commits viewer)
git gui (graphocal user interface for git)

ветки (локальный репозиторий):
-----------------------------------------------
git branch (вывод списка доступных веток)
git branch название (создание новой ветки)
git branch -m старое_название новое_название (переименование уже созданной ветки, если находишься в другой ветке; если нужно переименовать ту ветку, в которой находишься в данный момент, то старое_название указывать не надо, то есть: git branch -m новое_название)
git branch -D название (удаление ветки)
git checkout название (переключение на нужную ветку)
git checkout -b название (создание "отпочковывание" и последующее переключение на нужную ветку)
git checkout -b название v.1.0.0 (создание и последующее переключение на нужную ветку по состоянию на указанный тег, также можно указать определенный ХЭШ нужного состояния, например, git checkout -b название ff62561)
git merge название ветки (название ветки - это ветка, которая будут "слита" в текущую ветку)
git cherry-pick 15fc3b2 ("подтягивает" в ветку указанный коммит)
git cherry -v имя_ветки (просматриваем насколько текущий коммит отличается от указанной ветки)
git rebase имя_ветки (перемещение указанной ветки вперед всей истории)
git rebase -i HEAD~3 (соединить изменения трех последних комментов). Если после объединения попробовать запушить ветку, то ремоут-репозиторий сделает отказ, т.к. структура ветки будет отличаться от структуры ветки ремоут-репозитория. Для того, чтобы принудительно запушить ветку, в которой объединены комментарии необходимо указать опцию -force (или -f), например, git push origin -force. Считается, что форсирование опасно, при неумелых действия может повредить проект

ремоут-репозиторий:
-------------------------------
git push (пушит текущий проект и текущий ветку в ремоут-репозиторий)
git push origin название ветки (пушит в удаленный репозиторий имеющиеся изменения, origin - название текущего репозитория, можно вручную изменить в файле config)
git push origin название ветки (загрушает данные с удаленного репозитория в локальный, origin - название текущего репозитория, можно вручную изменить в файле config)
git push origin :название ветки (удаление ветки в удаленном репозитории, имя ветки предваряется двоеточием)
git push origin v.1.0.0 (отправка тега на удаленный репозиторий, необходимо явно указывать тег, в противном случае команда git push по умолчанию не отпраляет тег коммита)
git push origin :v.1.0.0 (удаление тега в ремоут-репозитории, перед именем тега ставится двоеточие)
git push origin tags (отправляет все имеющиеся теги в ремоут-репозиторий)
git ls-remote (запрос ссылки ремоут-депозитория, ассоциированное с текущим коммитом)
git ls-remote --tags (запрос имеющихся тегов из ремоут-депозитория)
git pull (получает данные тз удаленного репозититория и сливаем их с имеющимися ветками, то есть git pull - это по сути git fetch + git merge)
git fetch (получает данные из удаленного репозитория, но не сливаем их с ветками проекта, полученные данные помещаются в папку refs/remotes/)
git remote (получаем имеющиеся удаленные репозитории)
git remote add origin git@github.com:AleksandrGanov/GeekBrains.git (регистрация удаленного репозитория, origin можно изменить на свое имя, в этом случае во всех остальных командах, где есть origin, используем свой алиас)
git branch -r (получаем удаленные ветки, расположенные в удаленном репозитории)
git branch -vv (проверка "привязки" (upstreaming) локальных веток к удаленным)

переименование ветки на удаленном репозитории делается в несколько этапов: 
-- сначала создаем локальную ветку и привязываем (делаем up-stream) ее к ветке на удаленном репозитории (git branch to_delete origin/fix_error, то есть создаем локальную ветку to_delete и привязываем ее к ветке fix_error на удаленном репозитории)
-- пушим новую ветку на удаленный репозиторий (git push origin -u to_delete)
-- удаляем старую ветку (git push origin :fix_error), после выполнения ремоут-ветка будет удалена
можно сделать по-другому: https://www.kobzarev.com/programming/rename-git-local-and-remote-branches/


GIT-flow:
-------------
Это набор правил ветвления, который позволяет управлять релизами проекта. Для реализации механизма GF создают 2 ветки: master и develop
Постоянные ветки:
	-- master - это ветка, в которой содержится готовый к production релиз проекта, переда релиза из данной ветки никогда не должна приводит к поломке проекта
	-- develop - ветка разработки, когда изменения в ветке разработки достигают стабильного состояния (релиз), они вливаются в ветку master и помечены тегом с номером релиза
Вспомогательные ветки (с ограниченным временем жизни):
	-- ветки задач - используется для разработки новых функций, которые должны появиться в текущем или будущих релизах. При слиянии с основной веткой обязательно указывается тикет задачи, чтобы всегда можно было найти
	-- ветки релизов - используется для подготовки к выпуску новых продуктов, нужна для того, чтобы в релиза попало не все содержимое develop-ветки, а только избранные задачи. Есть 2 подхода для формирования релизных веток:
		1. создается заранее перед стартом релиза путем "отпочковая" от ветки develop (если ветка стабильна) и/или ветки master, по готовности релизной ветки она заливается как в develop, так и в релиз.
		2. второй подход - создание релизной ветки из отдельных задач, то есть от ветки develop "отпочковыватся" определенные задачи (feature-ветка)и по мере готовности включаются в релизную ветку, при этом ветки задач не удаляются и в любой момент времени есть возможность включить или исключить ту или иную задачу. Важно: коммиты создаются именно в ветках задача, а в релизную ветку включаются уже готовые реализацию задач. По готовности релизная ветка сливается и в develop и в master
	-- ветки hot-fix - предназначены для внесения небольших изменений в выпущенный релиз, для исправления ошибок, которые по каким-либо причинам не могли быть или были не обнаружены в процесс подготовки релиза. Если для фикса релиза требуется глобальные доработки, то стараются откатить релиз до стабильной версии и вносить необходимые изменения
	
	Структура окружений:
	---------------------------------
	master - продакш
	release, hot-fix - предпродакшн
	develop - стейджинг #1
	feature - стейджинг #1
	
===============================

конфигурация GIT:
---------------------------
-- C:\Users\Ганов\.gitconfig (глобальный файл конфигурации)
-- название проекта\.git\config (файл конфигурации конкретного проекта)
-- название проекта\.gitignore (файл игнора конкретного проекта, предназначен для того, чтобы прописать маски файлов, которые не должны комитится в git)
	например, *.log (игнорить все лог файлы и т.д.), строку игнора можно автоматически сформировать на сайте https://www.gitignore.io
--  гид игнорит все пустые папки, но если пустая папка нужна для функционирования, то в ней размещает файл .keep, пустой без расширения, в данном случае
	гит будет индексировать и коммитить данную папку, т.к. в ней появился файл. Win FileExplorer не даст создать такой файл, т.к. будет "ругаться", что перед точкой должно быть указано имя файла, поэтому такой файл можно создать, например, в редакторе Sublime Text, либо создать в виндоус любой файл, а потом в редакторе переименовать его в .keep
-- git config --global (установка глобальных данных ГИТа, сохраняются в глобальном файле конфигурации)
-- git config --global alias.имя_псевдонима текст_команды (создание алиаса для команды)
пример: (можно создать alias вручную в файле конфигурации в разделе [alias])
git config --global alias.mrggraph "log --pretty=format:'%С(yellow)%h%Creset - %C(green)%d%Creset %s %C(bold blue)(%cn) %C(green)%cd%Creset' --graph --date=format:'%d.%m.%Y %H:%M'"
git config --global alias.prlog "log --pretty=oneline"

консоль:
-----------
-- изменение кодовой страницы в win-консоле
	chcp 1251 (кодировака win1251 для русских шрифтов)
	chcp 866 (старая DOS-кодировка)
	сhcp 65001 (кодировка KOI8-R)
-- для открытия win-консоли держим шифт и нажмаем правой кнопкой внутри папки, в контекстном меню будет строка "открыть окно команд"
-- для открытия bash-консоли в контекстном меню выбираем "Git-Bash Here"
-- clear стирает все bash-консоле, cls - в win-консоле
-- для вставки в консоль скопированной в любой окне виндоус строки достаточно нажать правой кнопкой мыши
-- git help <command> (получение информации по конкретной команде)

GIT-bash (расширение функционала "Git Aware Prompt")
------------------------------------------------------------------------------
1. создаем в HOME-директории (C:\Users\Ганов) папку .bash
2. клонируем в данную папку удаленный репозиторий проекта "Git Aware Prompt" (git clone https://github.com/jimeh/git-aware-prompt.git)
3. создаем в директории .bash файл ".bash_profile"
4. прописываем в файле следующие строки:
	export GITAWAREPROMPT=~/.bash/git-aware-prompt
	source "${GITAWAREPROMPT}/main.sh"
	export PS1="\[\033]0;$MSYSTEM:\w\007\033[32m\]\u@\h:\[\033[33m\w \[$txtcyn\]\$git_branch\[$txtred\]\$git_dirty\[$txtrst\]\033[0m\]\$ "

полезные ссылки:
----------------------
https://code-live.ru/post/cpp-cyrillic-manual/ (решение вопроса с кодировками)
http://pr0git.blogspot.com/2015/02/git_4.html (решение вопроса с кодировками)
https://ab57.ru/cmdlist.html (список команда под консоль windows)
https://github.com/rsajob/docs/wiki/%5Bgit%5D-%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BF%D0%BE-ssh (генерация ключей через GIT-bach)
https://habr.com/ru/post/122445/ (общая инфа по SSH-подключениям)
https://habr.com/ru/post/266667/ (генерация ключей через GIT-GUI)
http://pr0git.blogspot.com/2015/02/git_18.html (статья "удаленные ветки")
http://danielkummer.github.io/git-flow-cheatsheet/index.ru_RU.html (gitflow)
https://ru.stackoverflow.com/questions/607001/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B5-%D0%B2%D0%B5%D1%82%D0%BA%D0%B8-%D0%BE%D1%81%D1%82%D0%B0%D1%8E%D1%82%D1%81%D1%8F-%D0%B2-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%BC-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B8-origin (почему смерженные ветки остаются в локальном репозитории)